# 優先順位システム

## 📌 概要

このアプリケーションは**2次元重要度システム**（S/A/B/C × S/A/B/C = 16段階）を採用していますが、階層構造と重要度の関係について、優先順位の判定ロジックが未確定です。

このドキュメントでは、現状の前提、発生する課題、および検討中の解決策をまとめます。

---

## 📋 現状の前提

### 基本原則

**階層が浅いタスクほど優先度が高い**

```
優先順位: 階層1 > 階層2 > 階層3 > 階層4
```

**理由:**
- 階層1は大きなプロジェクトやマイルストーン
- 階層2以降は具体的なタスクや実装詳細
- 上位の階層が完了しないと、下位の階層に着手できない

### 2次元重要度システム

各タスクには2つの重要度を設定可能：

| 重要度1 | 重要度2 | 優先度の例 |
|--------|--------|-----------|
| **S** (最高) | **S** (最高) | **SS** - 最優先 |
| **S** (最高) | **A** (高) | **SA** - 緊急かつ重要 |
| **A** (高) | **A** (高) | **AA** - 重要 |
| **B** (中) | **S** (最高) | **BS** - 緊急だが重要度は中 |
| **C** (低) | **C** (低) | **CC** - 最低優先 |

**重要度の意味（例）:**
- **重要度1**: ビジネスインパクト、プロジェクトへの影響度
- **重要度2**: 緊急度、期限の近さ

---

## ❓ 未解決の課題

### 問題: 階層と重要度が矛盾する場合の優先順位

#### ケーススタディ

以下のようなタスク構造がある場合、どちらを先に処理すべきか？

```markdown
- [ ] `#000001` α（タスクA）**[AA]** 📅 2025-10-20
  - [ ] `#000002` α-1（サブタスクA-1）**[BA]**

- [ ] `#000003` β（タスクB）**[BS]** 📅 2025-10-15
  - [ ] `#000004` β-1（サブタスクB-1）**[SS]**
```

**比較対象:**
- **タスクα（階層1、AA）** vs **タスクβ-1（階層2、SS）**

**判断の難しさ:**
1. **階層優先の場合**: α（階層1）を優先 → でもβ-1はSS（最高優先度）
2. **重要度優先の場合**: β-1（SS）を優先 → でもαは階層1（親タスク）
3. **期限優先の場合**: β（2025-10-15）を優先 → でもαの方が重要度は高い

**現実的な問題:**
- AI協調作業で複数のAIが同時に作業する場合、どのタスクに着手すべきか判断できない
- ユーザー自身も「次にやるべきタスク」が分からない

---

## 💡 検討中の解決策

### 案1: 点数化システム（スコアリング方式）

階層と重要度を数値化し、合計点で優先順位を決定する。

#### 案1-A: 階層重視型

**階層の重み:**
- 階層1: 基礎点 **100点**
- 階層2: 基礎点 **50点**
- 階層3: 基礎点 **25点**
- 階層4: 基礎点 **12点**

**重要度1の重み:**
- S = **10点**
- A = **8点**
- B = **6点**
- C = **4点**

**重要度2の重み:**
- S = **5点**
- A = **4点**
- B = **3点**
- C = **2点**

**計算式:**
```
総合スコア = 階層基礎点 + (重要度1の点数) + (重要度2の点数)
```

**例:**
```
α（階層1、AA）
  = 100 + 8 + 4 = 112点

β-1（階層2、SS）
  = 50 + 10 + 5 = 65点

→ α（112点）が優先
```

**特徴:**
- 階層が圧倒的に優先される
- 子タスクがどれだけ重要でも、親タスクを超えない
- シンプルで分かりやすい

---

#### 案1-B: バランス型

**階層の重み:**
- 階層1: 基礎点 **30点**
- 階層2: 基礎点 **20点**
- 階層3: 基礎点 **10点**
- 階層4: 基礎点 **5点**

**重要度1の重み:**
- S = **20点**
- A = **15点**
- B = **10点**
- C = **5点**

**重要度2の重み:**
- S = **10点**
- A = **8点**
- B = **5点**
- C = **2点**

**計算式:**
```
総合スコア = 階層基礎点 + (重要度1の点数) + (重要度2の点数)
```

**例:**
```
α（階層1、AA）
  = 30 + 15 + 8 = 53点

β-1（階層2、SS）
  = 20 + 20 + 10 = 50点

→ α（53点）が優先（僅差）
```

**特徴:**
- 階層と重要度のバランスが取れている
- 階層2のSSは階層1のBBを上回ることがある
- より柔軟な優先順位付けが可能

---

#### 案1-C: 重要度重視型

**階層の重み:**
- 階層1: 基礎点 **10点**
- 階層2: 基礎点 **8点**
- 階層3: 基礎点 **5点**
- 階層4: 基礎点 **3点**

**重要度1の重み:**
- S = **50点**
- A = **35点**
- B = **20点**
- C = **10点**

**重要度2の重み:**
- S = **25点**
- A = **18点**
- B = **10点**
- C = **5点**

**計算式:**
```
総合スコア = 階層基礎点 + (重要度1の点数) + (重要度2の点数)
```

**例:**
```
α（階層1、AA）
  = 10 + 35 + 18 = 63点

β-1（階層2、SS）
  = 8 + 50 + 25 = 83点

→ β-1（83点）が優先
```

**特徴:**
- 重要度が圧倒的に優先される
- 階層2のSSは階層1のAAを上回る
- 「緊急タスク」を優先したい場合に有効

---

### 案2: 親タスクの完了率を考慮

親タスクの進捗状況に応じて、子タスクの優先度を調整する。

**ルール:**
```
親タスクの完了率が50%未満の場合:
  → 子タスクの優先度を下げる（-30%）

親タスクの完了率が50%以上の場合:
  → 子タスクの優先度を上げる（+20%）
```

**例:**
```
α（階層1、AA、完了率0%）
  スコア = 112点

β（階層1、BS、完了率75%）
  スコア = 109点

β-1（階層2、SS、親タスク完了率75%）
  スコア = 65点 × 1.2 = 78点

→ α（112点）> β（109点）> β-1（78点）
```

**特徴:**
- 親タスクが進んでいる場合、子タスクの優先度が上がる
- 親タスクが未着手の場合、子タスクは後回し
- より現実的なプロジェクト管理に近い

---

### 案3: 期限を組み込んだ総合スコア

期限までの日数を考慮したスコアリング。

**計算式:**
```
期限ボーナス = max(0, 100 - (期限までの日数 × 5))
総合スコア = 階層基礎点 + 重要度点 + 期限ボーナス
```

**例:**
```
α（階層1、AA、期限まで10日）
  = 100 + 8 + 4 + (100 - 10×5)
  = 100 + 12 + 50
  = 162点

β（階層1、BS、期限まで3日）
  = 100 + 6 + 5 + (100 - 3×5)
  = 100 + 11 + 85
  = 196点

→ β（196点）が優先（期限が近い）
```

**特徴:**
- 期限が近いタスクが優先される
- デッドライン駆動のプロジェクトに最適
- ただし、期限がないタスクの扱いが難しい

---

### 案4: ユーザーが選択可能な方式

アプリ内で優先順位の計算方法を選択できるようにする。

**設定オプション:**
- [ ] **階層優先モード**: 階層を最重視（案1-A）
- [ ] **バランスモード**: 階層と重要度をバランス（案1-B）
- [ ] **重要度優先モード**: 重要度を最重視（案1-C）
- [ ] **期限優先モード**: 期限を最重視（案3）

**メリット:**
- ユーザーのワークスタイルに合わせられる
- プロジェクトの性質に応じて切り替え可能

**デメリット:**
- 実装が複雑
- AI協調作業時に、異なるAIが異なる優先順位で判断する可能性

---

## 📊 比較表

| 方式 | 階層の影響 | 重要度の影響 | 期限の影響 | 実装の複雑さ | 推奨度 |
|-----|----------|------------|----------|------------|-------|
| **案1-A 階層重視** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ❌ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| **案1-B バランス** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ❌ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **案1-C 重要度重視** | ⭐⭐ | ⭐⭐⭐⭐⭐ | ❌ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| **案2 完了率考慮** | ⭐⭐⭐⭐ | ⭐⭐⭐ | ❌ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| **案3 期限込み** | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **案4 選択可能** | （可変） | （可変） | （可変） | ⭐ | ⭐⭐⭐ |

---

## 🎯 推奨案（暫定）

### **案1-B: バランス型** を推奨

**理由:**
1. ✅ 階層と重要度のバランスが良い
2. ✅ 実装がシンプル（点数計算のみ）
3. ✅ 直感的に理解しやすい
4. ✅ AI協調作業でも一貫性が保たれる
5. ✅ 将来的に期限要素を追加可能

**実装例:**
```javascript
function calculatePriority(task) {
    // 階層点
    const levelPoints = {
        1: 30,
        2: 20,
        3: 10,
        4: 5
    };

    // 重要度1の点数
    const priority1Points = {
        'S': 20,
        'A': 15,
        'B': 10,
        'C': 5
    };

    // 重要度2の点数
    const priority2Points = {
        'S': 10,
        'A': 8,
        'B': 5,
        'C': 2
    };

    const levelScore = levelPoints[task.level] || 0;
    const p1Score = priority1Points[task.priority1] || 0;
    const p2Score = priority2Points[task.priority2] || 0;

    return levelScore + p1Score + p2Score;
}

// ソート例
tasks.sort((a, b) => calculatePriority(b) - calculatePriority(a));
```

---

## 🔮 将来の拡張案

### フェーズ1: 基本スコアリング（v0.23）
- 案1-Bの実装
- タスクリストをスコア順にソート表示
- Gistエクスポート時にスコアを表示

### フェーズ2: 期限の組み込み（v0.24）
- 期限ボーナスの追加
- 期限切れタスクの強調表示

### フェーズ3: 完了率の考慮（v0.25）
- 親タスクの完了率計算
- 子タスクの優先度調整

### フェーズ4: ユーザー設定（v0.26）
- 優先順位計算方法の選択UI
- プロファイル保存（LocalStorage）

---

## 📝 ディスカッションポイント

以下の点について、今後の検討が必要です：

### 1. 重要度の定義を明確化
- 重要度1と重要度2の具体的な意味は？
- プロジェクトによって解釈が変わる？

### 2. 期限の扱い
- 期限なしタスクはどう扱う？
- 期限超過タスクのペナルティは？

### 3. AI協調作業での課題
- 複数のAIが異なるタスクに着手した場合の調整方法は？
- タスクの「着手中」ステータスをどう管理する？

### 4. 動的な優先順位変更
- プロジェクトの進捗に応じて、優先順位を自動調整すべきか？
- ユーザーが手動で優先順位を上書きできるようにすべきか？

---

## 🔗 関連ドキュメント

- [README.md](../README.md) - プロジェクト概要
- [TASK_ID_DESIGN.md](TASK_ID_DESIGN.md) - タスクID設計方針
- [HANDOVER.md](../handover/HANDOVER.md) - 引き継ぎドキュメント

---

**作成日**: 2025年10月8日
**バージョン**: v0.22
**ステータス**: 検討中（未実装）
**更新履歴**:
- 2025-10-08: 初版作成、課題の整理と解決策の提案
