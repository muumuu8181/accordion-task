# タスクID設計方針

## 📌 概要

このアプリケーションでは、タスクIDに**通し番号方式**（`#000001`, `#000002`, `#000003`...）を採用しています。

このドキュメントでは、階層方式（`#000001-1`, `#000001-1-1`...）を採用しなかった理由と、通し番号方式の利点を説明します。

---

## 🎯 採用方式：通し番号方式

### 現在の実装

```markdown
- [ ] `#000001` タスクA
  - [ ] `#000002` タスクA-1
    - [ ] `#000003` タスクA-1-1
  - [ ] `#000004` タスクA-2
- [ ] `#000005` タスクB
```

**特徴:**
- すべてのタスクに一意の連番を付与
- 階層関係はIDではなく、Markdownのインデントで表現
- タスクの作成順序を追跡可能

---

## ❌ 検討したが不採用：階層方式

### 階層方式の例

```markdown
- [ ] `#000001` タスクA
  - [ ] `#000001-1` タスクA-1
    - [ ] `#000001-1-1` タスクA-1-1
  - [ ] `#000001-2` タスクA-2
- [ ] `#000002` タスクB
```

**特徴:**
- IDで親子関係を表現
- 視覚的に階層が分かりやすい

---

## ⚖️ 比較分析

| 評価項目 | 通し番号方式 | 階層方式 | 優位 |
|---------|------------|---------|------|
| **視認性** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 階層 |
| **親子関係の明示** | ❌ IDだけでは不明 | ✅ ID自体が階層を表現 | 階層 |
| **IDの永続性** | ✅ 移動しても不変 | ❌ 移動すると変わる | **通し** |
| **シンプルさ** | ✅ 常に6桁 | ⚠️ 階層が深いと長い（例: `#000001-2-3-1`） | **通し** |
| **実装の複雑さ** | ✅ シンプル | ⚠️ 移動時の再採番が複雑 | **通し** |
| **移動時の整合性** | ✅ IDは変わらない | ❌ IDを再計算する必要がある | **通し** |
| **作成順の追跡** | ✅ ID順 = 作成順 | ❌ 不可能 | **通し** |
| **一意性の保証** | ✅ 常に一意 | ✅ 一意 | 同等 |
| **業界標準との整合性** | ✅ GitHub, Jiraと同じ | ❌ 独自方式 | **通し** |

**総合評価: 通し番号方式が優位**

---

## 🚨 階層方式の致命的な問題

### 問題1: タスク移動時のID変更

**ケース: タスクを別の親に移動**

```markdown
# 移動前
- [ ] `#000001` プロジェクトA
  - [ ] `#000001-1` タスクX
- [ ] `#000002` プロジェクトB

# 移動後（タスクXをプロジェクトBに移動）
- [ ] `#000001` プロジェクトA
- [ ] `#000002` プロジェクトB
  - [ ] `#000002-1` タスクX  ← IDが変わってしまう！
```

**問題点:**
- **IDの履歴が追えない**: `#000001-1` → `#000002-1` に変わると、過去の議論やコミットログで参照できなくなる
- **参照の破損**: 外部ドキュメントやコメントで「タスク#000001-1について」と書いた場合、移動後に参照が無効になる
- **AI協調作業の混乱**: 複数のAIが同時に作業している場合、タスク移動によるID変更で混乱が生じる

### 問題2: 階層変更時の再採番コスト

**ケース: 階層を再構成**

```markdown
# 変更前
- [ ] `#000001` タスクA
  - [ ] `#000001-1` サブタスク1
    - [ ] `#000001-1-1` サブサブタスク1
    - [ ] `#000001-1-2` サブサブタスク2
  - [ ] `#000001-2` サブタスク2

# 「サブタスク2」を「サブサブタスク1」の下に移動
- [ ] `#000001` タスクA
  - [ ] `#000001-1` サブタスク1
    - [ ] `#000001-1-1` サブサブタスク1
      - [ ] `#000001-1-1-1` サブタスク2  ← #000001-2 から変更
    - [ ] `#000001-1-2` サブサブタスク2
```

**問題点:**
- すべての子孫タスクのIDも再計算が必要
- 実装が複雑になり、バグの温床になる
- ユーザー体験の悪化（移動のたびにIDが変わる）

### 問題3: 深い階層での可読性の低下

```markdown
- [ ] `#000001` プロジェクトA
  - [ ] `#000001-1` フェーズ1
    - [ ] `#000001-1-1` タスクグループ1
      - [ ] `#000001-1-1-1` 具体的タスク1  ← 長すぎて読みにくい
```

---

## ✅ 通し番号方式の利点

### 利点1: IDの永続性

```markdown
- [ ] `#000003` タスクX

# どこに移動しても、どの階層に移動しても
→ 常に `#000003` のまま
```

**メリット:**
- 過去の議論やコメントでの参照が永続的に有効
- GitHubのIssueやPRでタスクIDを参照しても、リンク切れが起きない
- AI協調作業時の混乱を防ぐ

### 利点2: シンプルな実装

```javascript
// 通し番号方式（シンプル）
this.displayIdCounter++;
task.taskId = String(this.displayIdCounter).padStart(6, '0');

// 階層方式（複雑）
const parentId = parent.taskId;
const siblingCount = parent.children.length;
task.taskId = `${parentId}-${siblingCount + 1}`;
// さらに移動時の再計算ロジックが必要...
```

### 利点3: 業界標準との整合性

**GitHub Issue番号:**
```
#1, #2, #3, #4...
```

**Jira チケット番号:**
```
PROJECT-1, PROJECT-2, PROJECT-3...
```

**Git コミットハッシュ:**
```
a1b2c3d, e4f5g6h... （一意の識別子、階層は別途表現）
```

→ すべて通し番号方式

### 利点4: 階層はMarkdownで明確に表現される

```markdown
- [ ] `#000001` タスクA
  - [ ] `#000002` タスクA-1  ← インデントで階層が明確
    - [ ] `#000003` タスクA-1-1  ← さらにインデント
```

**IDで階層を表現しなくても、Markdownの構造自体が階層を明示**

### 利点5: 作成順序の追跡

```markdown
- [ ] `#000001` 最初に作成
- [ ] `#000002` 2番目に作成
- [ ] `#000003` 3番目に作成
```

**プロジェクトの進行履歴を追跡可能**

---

## 🎨 階層の視覚化は別の方法で実現

通し番号方式でも、必要に応じて階層を視覚的に表現できます。

### 方法1: Markdownのインデント（現在採用）

```markdown
- [ ] `#000001` タスクA
  - [ ] `#000002` タスクA-1
    - [ ] `#000003` タスクA-1-1
```

### 方法2: 階層番号をタスク名に含める（オプション）

```markdown
- [ ] `#000001` 1. タスクA
  - [ ] `#000002` 1.1. タスクA-1
    - [ ] `#000003` 1.1.1. タスクA-1-1
  - [ ] `#000004` 1.2. タスクA-2
```

### 方法3: 絵文字で階層を表現（オプション）

```markdown
- [ ] `#000001` 📁 タスクA
  - [ ] `#000002` 📄 タスクA-1
    - [ ] `#000003` 🔹 タスクA-1-1
```

### 方法4: 親タスク参照を明示（オプション）

```markdown
- [ ] `#000001` タスクA
  - [ ] `#000002` タスクA-1 (親: #000001)
    - [ ] `#000003` タスクA-1-1 (親: #000002)
```

---

## 📚 参考: 他システムの事例

### GitHub Issues
- **ID方式**: 通し番号 (`#1`, `#2`, `#3`...)
- **階層表現**: ラベル、マイルストーン、プロジェクトボードで表現
- **移動**: Issueをプロジェクト間で移動してもIDは不変

### Jira
- **ID方式**: 通し番号 (`PROJECT-1`, `PROJECT-2`...)
- **階層表現**: Epic、Story、Subtaskという階層構造を別途持つ
- **移動**: チケット移動時もIDは不変

### Asana
- **ID方式**: 一意のハッシュID
- **階層表現**: セクション、タグで表現
- **移動**: タスク移動時もIDは不変

**すべて「IDは不変、階層は別の方法で表現」という設計**

---

## 🔮 将来の拡張性

### 通し番号方式なら対応可能

1. **タスクのマージ**: 2つのタスクを統合してもIDは保持
2. **タスクの分割**: 1つのタスクを分割しても元のIDは保持（新しい部分は新しいID）
3. **タスクのコピー**: コピー先は新しいIDを付与
4. **親の変更**: どの親に移動してもIDは不変
5. **エクスポート/インポート**: 他のシステムとの連携が容易

### 階層方式では困難

- タスクのマージ: 子タスクのIDをすべて再計算
- タスクの分割: IDの衝突が発生する可能性
- 親の変更: 全子孫のIDを再計算

---

## 📝 結論

**通し番号方式を採用する理由:**

1. ✅ **IDの永続性**: 移動しても変わらない
2. ✅ **シンプルな実装**: バグが少ない
3. ✅ **業界標準**: GitHub、Jiraと同じ
4. ✅ **作成順の追跡**: プロジェクト履歴が分かる
5. ✅ **AI協調作業**: IDの変更による混乱を防ぐ
6. ✅ **将来の拡張性**: 柔軟な機能追加が可能

**階層はMarkdownのインデントで十分に表現できる**

---

## 🔗 関連ドキュメント

- [README.md](../README.md) - プロジェクト概要
- [HANDOVER.md](../handover/HANDOVER.md) - 引き継ぎドキュメント
- [AI_PROMPT.md](../AI_PROMPT.md) - AI協調作業指示

---

**作成日**: 2025年10月8日
**バージョン**: v0.22
**ステータス**: 確定（実装済み）
